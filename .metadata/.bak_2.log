!SESSION 2024-06-18 08:59:50.466 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\workspace\1_Java\.metadata\.bak_1.log
Created Time: 2024-06-18 16:06:56.375

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:06:56.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:06:56.378
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:06:56.378
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:06:57.377
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0;)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:06:57.377
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:06:57.378
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:06:57.657
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0;)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:06:57.657
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:06:57.657
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:06:59.912
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:06:59.913
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:06:59.913
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:00.729
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:00.729
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:00.730
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:00.978
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:00.979
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:00.979
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:03.152
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:03.152
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:03.152
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:03.458
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:03.458
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:03.458
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:04.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:04.344
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:04.344
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:05.111
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:05.111
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:05.112
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:06.616
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[j)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:06.616
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:06.617
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:06.861
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[j)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:06.861
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:06.862
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:07.696
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:07.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:07.697
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:08.001
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:08.002
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:08.002
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:10.031
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:10.032
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:10.032
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:10.381
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:10.382
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:10.382
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:10.912
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i.])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:10.913
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:10.913
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:11.460
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i])
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:11.460
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:11.461
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:12.214
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:12.215
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:12.215
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:12.219
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:12.220
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:12.220
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:12.773
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].e)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:12.773
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:12.774
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:12.778
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].e)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:12.778
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:12.778
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:13.712
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].le)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:13.712
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:13.712
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:14.314
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:14.314
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:14.315
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:15.153
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:15.154
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:15.154
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:15.158
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:15.158
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:15.159
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:15.797
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:15.797
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:15.798
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:16.816
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:16.816
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:16.816
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:17.199
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:17.199
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:17.200
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:17.743
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++
								)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:17.743
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:17.744
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:18.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++
								)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:18.048
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:18.048
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:18.863
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:18.864
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:18.864
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:19.264
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:19.264
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:19.264
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:20.640
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:20.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:20.640
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:20.941
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:20.941
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:20.942
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:20.946
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++)
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:20.946
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:20.946
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:22.713
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:22.714
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:22.714
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:23.059
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:23.059
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:23.059
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:31.441
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:31.442
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:31.442
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:31.767
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:07:31.767
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:07:31.767
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:07:34.990
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(false);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:07:34.991
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:07:34.991
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:02.702
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(ran);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:02.703
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:02.703
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:04.408
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print();
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:04.409
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:04.409
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:06.088
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:06.088
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:06.089
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:07.695
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:07.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:07.696
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:09.458
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:09.458
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:09.458
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:10.316
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:10.317
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:10.317
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:11.344
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:11.344
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:11.344
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:11.695
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:11.695
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:11.695
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:12.512
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:12.513
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:12.513
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:12.861
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:12.861
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:12.861
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:14.087
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:14.087
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:14.088
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:14.907
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:14.907
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:14.907
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:16.375
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:16.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:16.375
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:17.760
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:17.760
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:17.760
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:25.705
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:25.705
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:25.705
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:35.260
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:35.261
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:35.261
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:37.045
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:37.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:37.048
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:37.719
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:37.719
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:37.719
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:38.725
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:38.725
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:38.725
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:41.685
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:41.685
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:41.686
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:42.984
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:42.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:42.984
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:43.310
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:43.310
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:43.310
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:45.097
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						prin
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:45.097
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:45.097
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:45.412
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						print
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:45.413
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:45.413
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:45.417
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						print
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:45.417
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:45.417
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:46.806
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:46.807
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:46.807
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:47.057
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
					
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:47.058
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:47.058
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:52.096
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:52.096
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:52.096
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:52.776
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println()
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:52.776
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:52.777
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:53.903
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-06-18 16:08:53.903
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-06-18 16:08:53.903
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:54.230
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:54.230
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:54.231
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:56.095
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:56.095
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:56.095
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:08:57.490
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:08:57.491
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:08:57.491
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:09:02.044
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:09:02.044
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:09:02.044
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:09:12.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:09:12.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-06-18 16:09:12.047
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-06-18 16:09:14.378
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.kh.practice.dimension;

import java.util.Scanner;

public class DimensionPractice {
	
	public void practice1() {
		// 1. 3행 3열짜리 문자열 배열 선언 및 할당
		String[][] arr = new String[3][3];
		
		// 2. 인덱스 0행 0열부터 2행 2열까지 차례대로 "(0,0)" 형식으로 값을 저장
		// arr.length => 2차원 배열의 길이. 즉, 행의 길이
		for(int i=0; i<arr.length; i++) {	// i: 행의 인덱스로 사용
			
			// arr[i].length => 1차원 배열의 길이. 즉, 열의 길이
			// arr[i] 는 문자열 데이터를 담고 있는 배열이다!
			
			for(int j=0; j<arr[i].length; j++) {	//j: 열의 인덱스로 사용
				// arr[i][j] 는 문자열 데이터다!
				arr[i][j] = "(" + i + ", " + j + ")";
			}
		}
		
		// 3. 저장된 값들을 출력
		for(int i=0; i<arr.length; i++) {
			for(int j=0; j<arr[i].length; j++) {
				System.out.print(arr[i][j]);
			}
			System.out.println();
		}
	}
	
//	===============================================
	public void practice2() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] numbers = new int[4][4];
		
		int value = 1;
		for(int i=0; i<numbers.length; i++) {	// 행의 인덱스.
			
			for(int j=0; j<numbers[i].length; j++) {	// 열의 인덱스.
				numbers[i][j] = value++; // 4 * i + (j + 1)
			}
		}
			
		// 값을 출력
		for (int i= 0; i<numbers.length; i++) {
			for(int j=0; j<numbers[i].length; j++) {
				System.out.printf("%-3d", numbers[i][j]);
			}
			System.out.println();		}
		}
//	==================================================
	
	public void practice4() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		//0행 0열 ~ 2행 2열까지 랜덤값 저장
		for (int i=0;i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
			}
		}
		
		// 마지막 행과 마지막 열에 값을 더하기
		/*
		 * sumArr[3][0] = sumArr[0][0] + sumArr[1][0] + sumArr[2][0];
		 * sumArr[3][1] = sumArr[0][1] + sumArr[1][1] + sumArr[2][1];
		 * sumArr[3][2] = sumArr[0][2] + sumArr[1][2] + sumArr[2][2];
		 */
		for (int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[3][i] += sumArr[j][i];
			}
		}
		
		/*
		 * sumArr[0][3] = sumArr[0][0] + sumArr[0][1] + sumArr[0][2];
		 * sumArr[1][3] = sumArr[1][0] + sumArr[1][1] + sumArr[1][2];
		 * sumArr[2][3] = sumArr[2][0] + sumArr[2][1] + sumArr[2][2];
		 */
		for(int i=0; i<3; i++) {
			for(int j=0; j<3; j++) {
				sumArr[i][3] += sumArr[i][j];
			}
		}
		
		/*
		 * sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
		 * 				+ sumArr[0][3] + sumArr[1][3] + sumArr[2][3]
		 */
		sumArr[3][3] = sumArr[3][0] + sumArr[3][1] + sumArr[3][2]
				     + sumArr[0][3] + sumArr[1][3] + sumArr[2][3];
		
		for(int i=0; i<sumArr.length; i++) {
			for(int j=0; j<sumArr.length; j++) {
				System.out.printf("%5d", sumArr[i][j]);
			}
			System.out.println();
		}
	}
//	===================================================
	public void practice4_1() {
		// 4행 4열 정수형 배열 선언 및 할당
		int[][] sumArr = new int[4][4];
		
		// 0행 0열부터 2행 2열까지는 1 ~ 10까지 임이의 정수 값 저장
		// 3행에는 각 열의 합을, 3열에는 각 행의 합, 3행 3열에는 가로 세로 합

		for(int i=0; i<sumArr.length; i++) {
			for (int j=0; j<sumArr[i].length; j++) {
				
				int lastRow = sumArr.length - 1;	// 마지막 행의 인덱스
				int lastCol = sumArr[i].length - 1;		// 마지막 열의 인덱스
				
				// 랜덤값을 각 위치에 저장(0,0 ~ 2,2)
				if (i != lastRow && j != lastCol) {
				sumArr[i][j] = (int)(Math.random() * 10 + 1);
				}
				
				System.out.printf("%d, %d\n, i, j");
				
				// 마지막 행의 위치에 현재 값을 더하기
				if (i < lastRow) {
					sumArr[lastRow][j] += sumArr[i][j];
				}
				
				// 마지막 열의 위치에 현재 값을 더하기
				if (j < lastCol) {
					sumArr[i][lastCol] += sumArr[i][j];
				}
			}
		}
	}
//	===============================================
		public void practice5() {
			
			
			Scanner sc = new Scanner(System.in);
			while(true) {
				
				System.out.print("행 크기 : ");
				int rowSize = sc.nextInt();
				
				System.out.print("열 크기 : ");
				int colSize = sc.nextInt();
				
				if (rowSize < 1 && colSize > 10) {
					System.out.println("반드시 1~10 사이의 정수를 입력해야 합니다.");
					continue;
				}
					
					int[][] arr = new int[rowSize][colSize];
					
					char eng;
					(eng >= 'A') && (eng <= 'Z');
					
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							arr[i][j] = (int)Math.random(eng);
						}
						
					for (int i=0; i<arr.length; i++) {
						for (int j=0; j<arr[i].length; j++) {
							System.out.print(arr[i][j]);
						}
						System.out.println();
					}
					
					
				}
				
			}
			
			
			
		}
		
		
		
	}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-06-18 16:09:14.378
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
